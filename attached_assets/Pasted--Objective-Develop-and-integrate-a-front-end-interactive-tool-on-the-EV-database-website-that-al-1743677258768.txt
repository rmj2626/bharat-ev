**Objective**: Develop and integrate a front-end interactive tool on the EV database website that allows users to estimate the real-world driving range of a selected EV model based on adjustable environmental and driving factors, using research-backed formulas specific to Indian conditions.

**Context**:  
- The estimator will be featured on individual EV model pages.  
- Each page provides:  
  - `realWorldRange` (integer, km): Real-world range at baseline conditions.  
  - `weight` (integer, kg): Kerb weight of the EV model.  
- **Assumption**: These values are accessible in JavaScript (e.g., as `window.evData.realWorldRange` and `window.evData.weight`, or via API at `/api/ev-model/:id`).  
- **Baseline Conditions**: 40°C, AC On, 100 kg payload + 75 kg driver, 20% City / 15% State Hwy / 65% Natl Hwy, 80 km/h.

**1. User Interface (UI) Requirements**:  
- **Temperature Slider**: 5°C–45°C, default 40°C, show value.  
- **Driving Mix Slider**:  
  - Segments: City%, State Hwy%, Natl Hwy% (sum = 100%).  
  - Mechanism: Multi-handle slider; dragging one handle adjusts adjacent segments proportionally to maintain 100%.  
  - Default: 20/15/65, show percentages.  
- **Climate Control Toggle**: On/Off, default On.  
- **Additional Weight Slider**: 0–600 kg, default 100 kg, show value.  
- **Average Speed Slider**: 40–120 km/h, default 80 km/h, show value.  
- **Estimated Range Display**: Large "XXX km" display, updates instantly on input change.  
- **Note**: Ensure UI is responsive across devices.

**2. Calculation Logic**:  
```javascript
// Constants
const Driver_Weight = 75; // kg
const HVAC_Baseline_Energy_Fraction = 0.125;
const Optimal_Temp = 22; // °C
const Baseline_Temp = 40; // °C
const HVAC_Temp_Coefficient = 0.1; // kW/°C
const Rolling_Resistance_Factor = 0.35;
const Speed_Model_Const_A = 0.0475; // kWh/km
const Speed_Model_Const_B = 0.000010625; // kWh/km/(km/h)^2
const Rel_Energy_City = 1.0;
const Rel_Energy_State = 1.25;
const Rel_Energy_National = 1.5;
const Baseline_Speed = 80; // km/h

// Inputs (example)
let T = 40; // user_selected_temperature (°C)
let CityP = 0.20; // user_city_percentage / 100
let StateP = 0.15; // user_state_percentage / 100
let NationalP = 0.65; // user_national_percentage / 100
let AC_On = true; // user_ac_status == 'On'
let Add_Weight = 100; // user_additional_weight (kg)
let User_Speed = 80; // user_average_speed (km/h)
let Base_Range = 300; // realWorldRange (km, from database)
let K_Weight = 1500; // weight (kg, from database)

// a) Battery Temperature Efficiency
function calculateEfficiency(T) {
    if (T >= 15 && T <= 35) return 1.0;
    else if (T < 15) return Math.max(0.5, 1.0 - 0.005 * (15 - T));
    else return 1.0; // T > 35
}
let efficiency_T = calculateEfficiency(T);

// b) Relative HVAC Energy Consumption
let relative_E_HVAC = 0;
if (AC_On && User_Speed > 0) {
    let deltaT_base = Math.abs(Baseline_Temp - Optimal_Temp); // 18
    let deltaT_user = Math.abs(T - Optimal_Temp);
    relative_E_HVAC = (deltaT_user / deltaT_base) * HVAC_Baseline_Energy_Fraction * (Baseline_Speed / User_Speed);
}

// c) Driving Mix Energy Factor
let E_base_mix = (0.20 * Rel_Energy_City) + (0.15 * Rel_Energy_State) + (0.65 * Rel_Energy_National); // 1.3625
let E_user_mix = (CityP * Rel_Energy_City) + (StateP * Rel_Energy_State) + (NationalP * Rel_Energy_National);
let Factor_mix = E_base_mix > 0 ? E_user_mix / E_base_mix : 1.0;

// d) Weight Energy Factor
let m_base = K_Weight + Driver_Weight + 100;
let m_new = K_Weight + Driver_Weight + Add_Weight;
let Factor_weight = m_base > 0 ? 1 + Rolling_Resistance_Factor * ((m_new / m_base) - 1) : 1.0;

// e) Speed Energy Factor
function calculateEnergyPerKm(speed) {
    return Speed_Model_Const_A + Speed_Model_Const_B * Math.pow(speed, 2);
}
let E_base_speed = calculateEnergyPerKm(Baseline_Speed);
let E_user_speed = calculateEnergyPerKm(User_Speed);
let Factor_speed = E_base_speed > 0 ? E_user_speed / E_base_speed : 1.0;

// f) Integrated Range Estimation
let propulsion_energy_fraction = 1.0 - HVAC_Baseline_Energy_Fraction;
let relative_E_propulsion = propulsion_energy_fraction * Factor_mix * Factor_speed * Factor_weight / efficiency_T;
let relative_E_total_new = relative_E_propulsion + relative_E_HVAC;
let Factor_total = relative_E_total_new > 0 ? 1 / relative_E_total_new : 0;
let Range_estimated = Base_Range * Factor_total;

document.getElementById('estimatedRangeDisplay').innerText = Math.round(Range_estimated) + " km";
Use HTML/CSS/JavaScript, compatible with modern browsers.
Update range in real-time using oninput (sliders) and onchange (toggle).
Optimize calculations for performance (e.g., cache unchanged factors).
Validation: Ensure sliders stay within bounds; driving mix maintains 100% (e.g., if City% +10%, reduce Natl Hwy% unless 0, then State Hwy%).
Accessibility: Use ARIA labels (e.g., aria-valuenow) and visible focus states.
Testing: Verify with sample inputs (e.g., realWorldRange = 300 km, weight = 1500 kg) across extremes.
4. Deliverable:

Functional code integrated into EV model pages, using realWorldRange and weight.  note - JS Input Section: In the Calculation Logic section, the let T = 40; ... let K_Weight = 1500; lines are clearly marked as // Inputs (example).make sure you I understand these are placeholders and the actual values must be dynamically read from the UI controls (T, CityP, StateP, NationalP, AC_On, Add_Weight, User_Speed) and the page data (Base_Range, K_Weight) within the event handlers.